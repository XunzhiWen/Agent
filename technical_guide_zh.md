# AI Agent 技术详解指南 (小白必读)

这份文档将带你深入了解我们刚刚搭建的 AI Agent (智能体) 项目。即使你从未写过代码，也能通过本文理解它背后的黑科技。

## 1. 什么是 AI Agent (智能体)?

想象一下，ChatGPT 就像一个**超级百科全书**，你问它答，但它无法主动帮你“做事”（比如查现在的天气、算复杂的数学题）。

**AI Agent (智能体)** 就是给这个百科全书装上了：
*   **手 (Tools)**：可以上网搜索、按计算器。
*   **耳朵 (Input)**：听你的指令。
*   **嘴巴 (Output)**：回答你。
*   **大脑 (Brain)**：决定什么时候该说话，什么时候该动手。

在这个项目中，我们从零打造了一个这样的智能体。

---

## 2. 核心技术栈 (我们用了什么?)

为了造出这个 Agent，我们使用了以下关键技术：

### 2.1 Python (编程语言)
这是我们的**地基**。Python 是 AI 领域最流行的语言，因为它简单易读，拥有庞大的生态库。

### 2.2 Google Gemini (大模型/大脑)
*   **角色**: 大脑。
*   **技术**: `google-genai` SDK。
*   **作用**: 它负责理解你说的话 (比如 "算一下 50*2")，并决定是直接回答你，还是去调用工具。我们使用的是 `gemini-2.5-flash` 模型，它速度快且免费额度大。

### 2.3 LangGraph (骨架/工作流)
这是本项目的**核心框架**。
*   **为什么不用普通的循环?** 普通的代码是线性的 (第一步 -> 第二步)。但 Agent 的思维是复杂的 (思考 -> 决定用工具 -> 用完工具 -> 再思考 -> 发现不够 -> 再用工具...)。
*   **LangGraph 的概念**:
    *   **Graph (图)**: 整个 Agent 的思维地图。
    *   **State (状态)**: Agent 的**短期记忆**。在这里，它是一个列表 (`messages`)，记录了你说的话、Agent 的回复、工具的结果。
    *   **Node (节点)**: 地图上的站点。我们有两个主要节点：
        1.  `agent`: 调用大脑 (Gemini) 进行思考。
        2.  `tools`: 执行动作 (比如真的去搜索)。
    *   **Edge (边)**: 站点之间的路线。我们定义了条件边 (`should_continue`)：如果大脑说“我要用工具”，就走去 `tools` 节点；否则就结束。

### 2.4 Tools (工具/手)
*   **定义**: 我们在 `src/tools.py` 里写了两个函数：
    1.  `calculator`: 一个简单的计算器。
    2.  `search`: 一个模拟的搜索引擎 (假装在联网)。
*   **原理**: 我们把这些工具的“说明书”发给 Gemini，Gemini 看到说明书后，就会在需要的时候告诉我们：“请帮我运行 calculator，参数是 50*2”。

---

## 3. 项目文件结构详解

*   **`main.py` (入口)**:
    *   这是程序的启动台。它负责接收你的输入，把任务交给 Agent，然后把 Agent 的反应打印出来。
    *   *注意*: 目前的 `main.py` 每次对话都是全新的开始，没有保存上一轮的对话历史 (这是为什么它记不住你之前说了啥)。

*   **`src/graph.py` (核心逻辑)**:
    *   这里定义了 Agent 的**思维导图**。
    *   它负责把 LangChain 格式的消息 (HumanMessage) 翻译成 Gemini 能看懂的格式 (Content)。
    *   它把 `agent` 节点和 `tools` 节点连接起来，形成一个闭环。

*   **`src/tools.py` (工具箱)**:
    *   存放了 Agent 可以使用的所有工具。

*   **`.env` (配置文件)**:
    *   存放你的 API Key。这是机密文件，不能发给别人。

---

## 4. Agent 是怎么思考的? (工作流程)

当你输入 "计算 50 * 2" 时，后台发生了什么？

1.  **Start**: `main.py` 接收输入，打包成消息，扔给 `graph.py`。
2.  **Node: Agent**:
    *   Agent 把消息发给 Gemini。
    *   Gemini 思考后返回: "我需要使用 `calculator` 工具，参数是 `50 * 2`"。
3.  **Edge: Check**:
    *   系统检查 Gemini 的回复，发现它想用工具。
    *   于是系统决定：**不结束**，跳转到 `tools` 节点。
4.  **Node: Tools**:
    *   系统运行 `calculator` 函数，算出 `100`。
    *   系统把 `100` 包装成一个“工具消息”，塞回给 Agent 的记忆里。
5.  **Node: Agent (Again)**:
    *   Agent 再次被唤醒。这次它看到了:
        *   用户: "计算 50 * 2"
        *   自己: "我要用计算器..."
        *   工具: "结果是 100"
    *   Gemini 再次思考，觉得信息够了，返回: "答案是 100"。
6.  **Edge: Check**:
    *   系统检查回复，发现这次不需要工具了。
    *   **结束**。
7.  **Output**: `main.py` 把 "答案是 100" 打印在屏幕上。

这就是一个完整的 **ReAct (Reasoning + Acting)** 循环！

---

## 5. 长期记忆 (Memory/Persistence) 是如何实现的？

你可能注意到了，现在的 Agent 能记住你之前说了什么。这是怎么做到的？

### 5.1 MemorySaver (检查点机制)
*   **技术**: LangGraph 的 `MemorySaver`。
*   **原理**: 每次对话结束后，LangGraph 会把整个 `state['messages']` (对话历史) 保存到内存中。
*   **配置**: 通过 `thread_id` 来标识不同的对话会话。相同的 `thread_id` = 相同的对话历史。

### 5.2 工作流程
1.  **第一轮对话**: 你说 "我叫小明"。
    *   Agent 回复并保存到 `thread_id="1"` 的历史中。
2.  **第二轮对话**: 你说 "我叫什么名字？"
    *   系统加载 `thread_id="1"` 的历史。
    *   Agent 看到完整历史：
        *   User: "我叫小明"
        *   AI: "你好小明..."
        *   User: "我叫什么名字？"
    *   Agent 基于历史回答："你叫小明"。

### 5.3 代码实现
*   **`src/graph.py`**: 使用 `MemorySaver()` 作为 `checkpointer`。
*   **`main.py`**: 传递 `config={"configurable": {"thread_id": "1"}}` 给 `app.stream()`。

---

## 6. 当前限制与未来改进

### 6.1 当前限制
*   **内存持久化**: 目前使用的是 `MemorySaver`，它只保存在**运行时内存**中。如果你重启程序，对话历史就丢失了。
*   **单线程**: 所有对话都使用同一个 `thread_id="1"`，无法区分不同用户。

### 6.2 未来改进方向
1.  **数据库持久化**: 将 `MemorySaver` 替换为 `SqliteSaver` 或 `PostgresSaver`，把对话历史保存到数据库。
2.  **多用户支持**: 为每个用户分配唯一的 `thread_id`。
3.  **真实工具**: 把 `search` 工具换成真正的搜索 API (如 Tavily、Google Search)。
4.  **更多工具**: 添加天气查询、文件操作、发送邮件等功能。

---

## 7. 如何学习更多？

*   **LangGraph 官方文档**: https://langchain-ai.github.io/langgraph/
*   **Gemini API 文档**: https://ai.google.dev/
*   **实践建议**: 尝试修改 `src/tools.py`，添加你自己的工具！
